description: Claude Code (CLI agent where file operations, basic edits, etc. are already covered; single project mode)
prompt: |
  You are running in a CLI coding agent context where file operations, basic (line-based) edits and reads
  as well as shell commands are handled by your own, internal tools.

  MANDATORY TOKEN OPTIMIZATION RULES FOR CODE AND MARKDOWN FILES:

  File Size Rules:
  - Files < 100 lines: Prefer symbolic tools, Read() acceptable
  - Files 100-200 lines: MUST use get_symbols_overview() first
  - Files > 200 lines: FORBIDDEN to use Read(), symbolic tools ONLY

  Symbolic tools provide 70-95% token savings compared to reading entire files.

  Examples:
  - Get file structure: mcp__murena__get_symbols_overview(relative_path="src/file.py", depth=2)
    → ~1,000 tokens instead of 20,000+ for full file read (95% savings)
  - Find function: mcp__murena__find_symbol(name_path_pattern="MyClass/my_method", include_body=True)
    → ~500 tokens per symbol instead of reading full file
  - Search pattern: mcp__murena__search_for_pattern(substring_pattern="keyword", relative_path="src/")
    → 200-500 tokens for targeted search

  For non-code files or when you need specific sections, use pattern search.
  For repeated access to same file: use cached symbols (~100 tokens, 99% savings!).

excluded_tools:
  # Phase 1-4: Built-in overlaps and IDE-specific tools
  - create_text_file
  - read_file
  - execute_shell_command
  - prepare_for_new_conversation
  - replace_content
  # JetBrains-specific tools (not needed in CLI context)
  - jet_brains_find_symbol
  - jet_brains_find_referencing_symbols
  - jet_brains_get_symbols_overview
  - jet_brains_type_hierarchy

  # Phase 5: Low-risk removals (7 tools, ~420 tokens saved)
  # Alternative: Use Bash("ls -la") instead
  - list_dir
  # Alternative: Use Edit() tool instead
  - delete_lines
  - replace_lines
  - insert_at_line
  # Alternative: Use Edit()/Write() directly on CHANGELOG.md
  - update_changelog
  # Alternative: Use delete_memory() + write_memory()
  - edit_memory
  # Alternative: Use git diff/log commands
  - summarize_changes

included_optional_tools:
  # Phase 4: Semantic search tools (NEW)
  - intelligent_search          # Universal search (LSP+VECTOR+HYBRID auto-routing)
  - find_similar_code          # Clone detection with AST analysis
  - get_semantic_index_status  # Check index status before search

tool_description_overrides:
  search_for_pattern: >
    Pattern search across files with context lines and glob filtering.
    Prefer symbolic tools for code navigation. Returns file paths to matched lines.
  find_symbol: >
    Find symbols (classes, methods, etc.) by name path pattern.
    Returns symbol info with optional body and children (specify depth).
  get_symbols_overview: >
    Get hierarchical overview of symbols in a file.
    Returns grouped symbols by kind (Class, Method, Function, etc.).
  find_referencing_symbols: >
    Find all locations where a symbol is used.
    Returns referencing symbols with context snippets.
  replace_symbol_body: >
    Replace the body of a symbol (function, method, class).
    Safer than line-based edits (no line number dependencies).

  # Phase 4: Semantic search tools
  intelligent_search: >
    Universal search with automatic mode selection (LSP/VECTOR/HYBRID).
    Phase 4 features: cross-encoder reranking, query expansion, confidence-based fallback.
    Use for: "find auth logic", "UserService", "error handling patterns".
  find_similar_code: >
    Multi-level clone detection: AST structural similarity + semantic embeddings.
    Detects Type-1 (exact), Type-2 (renamed), Type-3 (modified), Type-4 (semantic) clones.
    Use for: duplicate detection, similar implementations, refactoring opportunities.
  get_semantic_index_status: >
    Check semantic index status for the current project.
    Returns indexing progress, file counts, and whether search is available.

# whether to assume that Murena shall only work on a single project in this context (provided that a project is given
# when Murena is started).
# If set to true and a project is provided at startup, the set of tools is limited to those required by the project's
# concrete configuration, and other tools are excluded completely, allowing the set of tools to be minimal.
# Tools explicitly disabled by the project will not be available at all.
# The `activate_project` tool is always disabled in this case, as project switching cannot be allowed.
single_project: true

# Enable automatic docstring compression to reduce token consumption
compact_descriptions: true
